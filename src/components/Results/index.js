import React, { useState } from 'react';

import reduceShops from '../../utils/reduceShops.js';

import ShopCard from '../ShopCard';

import './results.css';

// For each item, determine the best place or places to get it.
// An item can be bought in several places.
// There is a hierarchy of plastic, unpackaged, paper etc. Sort by it.
// Pick the first of the array and any which are the same as it.

const initialShopsHierarchy = [
  'milkandmore',
  'beetroot',
  'proudsow',
  'byo',
  'budgens',
  'brockleymarket',
  'sainsburys',
  'gather',
  'villagegrocer',
  'jones',
  'planet',
  'asnature',
  'grocery',
  'swop',
];

const packagingHierarchy = [
  'returnable',
  'unpackaged',
  'reusable',
  'paper',
  'card',
  'glass',
  'metal',
  'wax',
  'other',
  'plastic',
];

// const chooseSources = sources => sources.map(item => ({
//   ...item,
//   source: item.sources[0],
// }));

// // This chooses one shop to buy each item at.
// // Really, we want to reduce the number of shops we have to traipse around.
// // Start off with a list of shops from the results generated by this, which gives us
// // local / favourite preferences. (we can start off with ALL) shops to get a more
// // optimised thing, but this would probably result in us going further overall, as
// // the absolute best shops will be miles away.)
// // Then, recursively, see what happens if we remove one shop. If we can still buy everything,
// // remove another. Store the shop list and number of trips.

const sortByEco = (a, b) =>
  packagingHierarchy.indexOf(a.type) - packagingHierarchy.indexOf(b.type);

const Results = ({ list, data }) => {
  console.log('rendering results');
  const [shopsHierarchy, setShopsHierarchy] = useState(initialShopsHierarchy);
  const [fewerTrips, setFewerTrips] = useState(true);

  const sendToTop = id =>
    setShopsHierarchy([id, ...shopsHierarchy.filter(shopId => shopId !== id)]);

  const sendUp = id => {
    const idIndex = shopsHierarchy.indexOf(id);
    if (idIndex < 1) {
      return;
    }
    if (shopsHierarchy.length === idIndex + 1) {
      setShopsHierarchy([
        ...shopsHierarchy.slice(0, idIndex - 1),
        id,
        shopsHierarchy[idIndex - 1],
      ]);
    } else {
      setShopsHierarchy([
        ...shopsHierarchy.slice(0, idIndex - 1),
        id,
        shopsHierarchy[idIndex - 1],
        ...shopsHierarchy.slice(idIndex + 1),
      ]);
    }
  };
  const sendDown = id => {
    const idIndex = shopsHierarchy.indexOf(id);
    if (idIndex + 1 === shopsHierarchy.length) {
      return;
    }
    if (idIndex === 0) {
      setShopsHierarchy([
        shopsHierarchy[idIndex + 1],
        id,
        ...shopsHierarchy.slice(idIndex + 2),
      ]);
    } else {
      setShopsHierarchy([
        ...shopsHierarchy.slice(0, idIndex),
        shopsHierarchy[idIndex + 1],
        id,
        ...shopsHierarchy.slice(idIndex + 2),
      ]);
    }
  };;
  const sendToBottom = id =>
    setShopsHierarchy([...shopsHierarchy.filter(shopId => shopId !== id), id]);

  const sortByShop = (a, b) =>
    shopsHierarchy.indexOf(a.shop) - shopsHierarchy.indexOf(b.shop);

  const sortByShopName = (a, b) => {
    const hierarchy = [...shopsHierarchy, 'elsewhere'];
    return hierarchy.indexOf(a) - hierarchy.indexOf(b);
  };
  // Determine ALL the best places to buy things, based on the lowest impact packaging
  const bestSources = list.map(item => {
    const itemData = data.sources.filter(s => s.name === item)[0];
    const itemSource = itemData ? itemData.sources.sort(sortByEco) : [];
    const best = itemSource
      .filter((el, index) => {
        if (index === 0) return true;
        return el.type === itemSource[0].type;
      })
      .sort(sortByShop);

    return { name: item, sources: best };
  });

  // Select just one of these shops per item
  // e.g. [
  //   {
  //     name: 'Cornflakes',
  //     sources: [
  //       { shop: 'gather', type: 'unpackaged' },
  //       { shop: 'asnature', type: 'unpackaged' },
  //     ],
  //     source: { shop: 'gather', type: 'unpackaged' },
  //   },
  // ];
  const chosenSources = reduceShops(bestSources, shopsHierarchy, {
    preferLocal: !fewerTrips,
  });

  // Collate a list, by shop
  // e.g. {
  //   gather: [
  //     {
  //       name: 'Cornflakes',
  //       sources: [
  //         { shop: 'gather', type: 'unpackaged' },
  //         { shop: 'asnature', type: 'unpackaged' },
  //       ],
  //       source: { shop: 'gather', type: 'unpackaged' },
  //     },
  //     {
  //       name: 'Baking powder',
  //       sources: [{ shop: 'gather', type: 'unpackaged' }],
  //       source: { shop: 'gather', type: 'unpackaged' },
  //     },
  //   ],
  //   budgens: [
  //     {
  //       name: 'Rice Krispies',
  //       sources: [
  //         { shop: 'budgens', type: 'plastic' },
  //         { shop: 'sainsburys', type: 'plastic' },
  //       ],
  //       source: { shop: 'budgens', type: 'plastic' },
  //     },
  //   ],
  // };
  const shoppingListByShop = chosenSources.reduce((acc, cur) => {
    if (cur.source) {
      return {
        ...acc,
        [cur.source.shop]: acc[cur.source.shop]
          ? [...acc[cur.source.shop], cur]
          : [cur],
      };
    }
    return acc;
  }, {});

  return (
    <div className="results">
      <h2 className="results__title">Where to buy it</h2>
      <div className="results__options">
        <input
          type="checkbox"
          id="results-option"
          name="results-option"
          checked={fewerTrips}
          onChange={e => setFewerTrips(e.target.checked)}
        />
        <label htmlFor="results-option" className="results__option-label">
          Prefer fewer trips
        </label>
      </div>
      {!list.length && (
        <p className="results__empty-info">
          Add some items to your shopping list and find out where to buy them
        </p>
      )}
      {Object.keys(shoppingListByShop)
        .sort(sortByShopName)
        .map(shop => {
          const shopDetails = data.shop.filter(s => s.id === shop)[0] || {
            name: 'No sources found',
          };
          return (
            <ShopCard
              key={shopDetails.name}
              shopDetails={shopDetails}
              items={shoppingListByShop[shop]}
              sendToTop={sendToTop}
              sendUp={sendUp}
              sendDown={sendDown}
              sendToBottom={sendToBottom}
            />
          );
        })}
    </div>
  );
};

export default Results;
